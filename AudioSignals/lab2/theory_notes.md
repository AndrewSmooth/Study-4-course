Датасет со звуками города: сигналы машин, лай собак, разговоры и др.
Частота дискретизации 16к, значит максимальная частота 8к по теореме котельникова Найквиста шеннона

Скачиваем датасет, разделаяем по фолдам и фолды по группа: обучение, валидация, тест. Мапим лейблы с айди, выводим все лейблы

Преобразуем айдиофайлы из датасета в мел-спектрограммы как в 1 лабе, извлекаем характеристики и на них обучаем SVM-классификатор:
```bash
N_MELS, N_FFT, HOP = 64, 1024, 256
FMIN, FMAX = 20.0, SR/2
```

N_MELS = 64 — количество мел-фильтров (высота спектрограммы)
N_FFT = 1024 — размер окна для FFT (определяет частотное разрешение)
HOP = 256 — шаг между окнами (определяет временное разрешение)
FMIN = 20.0 — минимальная частота (20 Гц — нижний предел слуха)
FMAX = SR/2 — максимальная частота (частота Найквиста — SR/2)

64 - это сколько на сколько полос будут разделены все частоты, которые мы извлекли. Оптимальный размер 64

```bash
Частотная полоса — это "корзина" частот, которая объединяет энергию звука в определённом частотном диапазоне.

# Например, для SR = 22050 Гц:
все_частоты = [0, 11025] Гц  # от 0 до частоты Найквиста
разбили_на_64_полосы = [
    полоса_0: [0, 172] Гц,
    полоса_1: [172, 344] Гц,
    ...
    полоса_63: [10883, 11025] Гц
]
```
Мы делаем feature engineering(в методе logmel stats). То есть из сырых аудиофайлов извлекаем фичи. Какие именно? Грубо говоря тензор(np.array) [64, T]:
```bash
Выглядит это так: [
    1 [num1, num2, num3, .. numT ]
    2 [..]
    ..
    64 [..]
]

64 - количество полос
T - количество временных меток. Формула:

T = (N - N_FFT) // HOP_LENGTH + 1

N - общее количество отсчётов в аудиосигнале
N_FFT - размер окна для FFT
HOP_LENGTH - шаг между окнами
// - целочисленное деление (отбрасываем дробную часть)
```

Как формируются числа num1, num2, num3(вместе образуют окно):
Берем список семплов в какой-то момент времени и прогоняем через быстрое преобразование фурье:
samples(например 1024 записи) -> FFT -> окно(64 записи)
Как это происходит:
![alt text](window_visualize.jpg)

Пайплайн обучения состоит из Scaler и Линейный SVM классификатор
Scaler:
```bash
Приводит все признаки к одинаковому масштабу с mean=0 и std=1.
X_scaled = (X - mean) / std
```

LinearSVM:
```bash
Находит веса(птимальную линейную границу между классами)
```



https://freesound.org/search
https://colab.research.google.com/drive/1D6w3elhiRofsTGU9QfjaAiWcvJ4rofrx#scrollTo=hSKaiYH3nlrd

