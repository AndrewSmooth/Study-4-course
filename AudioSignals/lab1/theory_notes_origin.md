# Мои заметки, объяснения, которые я понял

Сэмплирование, выборка, дискретизация - измеряем значения непрерывного (плавного, без разрывов) сигнала через равные промежутки времени

Сэмпл - амплитуда в конкретный момент времени
Число сэмплов - общее количество таких измерений в аудиофайле. Зная число сэмплов и частоту дискретизации можно узнать длительность (n_samp/част.дискр.)

Частота дискретизации - сколько раз измерили за секунду. [Гц]
Высокое разрешение - 192кГц
Для обучения 16кГц, т.к. речь человека в пределах 8кГц
У данных должна быть одинаковая частота дискретизации. Для этого Передискретизация

Амплитуда - громкость (давление звука) [Дб]

Битовая глубина - насколько точно измерена амплитуда (можно сравнить с глубиной цвета, чем больше цветов, тем точнее можно описать картину. Здесь так же с амплитудой) [Бит] обычно 16 или 24бит

`Количество каналов` - 1 моно 2 стерео (левый правый) 3 многоканальное (кино игры)
`peak_level` - максимальная амплтуда
`rms_level` - громкость
`clipping_ratio` - Долю сэмплов с амплитудой ≥ 0.999. Пример: Clipping=0.05 - 5% звука искажено
Клипппинг - это когда амплитуда превышает максимум для этой цифровой системы
`zcr` - zero crossing rate - насколько мелко и часто колеблется звук вокруг тишины (ехать по стиральной доске - высокий). Нужен, чтобы отличать где речь а где шум, определение ударных, инструментов
`центроид и полоса` - Центроид - это "цвет" звука, а полоса - насколько он "чистый" или "смешанный"!
Низкий центроид + узкая полоса = группа невысоких людей одинакового роста
Высокий центроид + широкая полоса = смесь очень высоких и очень низких людей
ФЛейта против скрипки, определени тембра (темный яркий звук) Широкий спектр значит шум
Спектральная полоса (Bandwidth)
Что показывает: Насколько "размазан" спектр вокруг центроида

`p95` - 95й процентиль - значение, которое превышают только 5% данных
Если p95(duration) = 8.0, значит 95% файлов короче 8 секунд

```bash
Качественная запись:
Peak < 0.9, Clipping ≈ 0.0, RMS 0.05-0.2

Проблемная запись:
Peak > 0.95 + Clipping > 0.01 = искажения
RMS < 0.02 + Peak < 0.3 = слишком тихая
High ZCR + Wide bandwidth = шум
```

`wavefoem` - сырое представление звука. Чисто амплитуда и время, без полутонов, шепотов и т.д.

`STFT` - short time furie transform - то же самое, только вместо амплитуды частота.
`spectrogram dB` - это как физически выглядит звук с частотой и временем. В иделе, по математике.
Но человек так не слышит звук. Чтобы показать, как слышит человек надо сделать mel(melody) и log спектрограмму

`MEL`
Наше ухо нелинейно воспринимает частоту.

Линейная шкала (Герцы): Разница между 100 Гц и 200 Гц равна 100 Гц. Разница между 10 000 Гц и 10 100 Гц тоже равна 100 Гц.

Восприятие человека: Мы воспринимаем переход от 100 Гц к 200 Гц как огромный скачок (на октаву вверх!). А переход от 10 000 Гц к 10 100 Гц будет едва заметным изменением "писка".

Mel-шкала "исправляет" это: Она "растягивает" низкие частоты и "сжимает" высокие. В результате:

На Mel-спектрограмме расстояние между 100 Гц и 200 Гц будет визуально большим.

Расстояние между 10 000 Гц и 10 100 Гц будет визуально маленьким.

`LOG`
Наше восприятие громкости также нелинейно.

Линейная шкала мощности: Чтобы звук воспринимался как вдвое громче, его физическая мощность должна увеличиться примерно в 10 раз.

Пример: Если один звук имеет мощность 1 единица, а другой — 10 единиц, мы не услышим его "в 10 раз громче", а всего лишь примерно "в 2 раза громче".

Логарифмирование амплитуды (Log) "исправляет" и это:
Оно сжимает динамический диапазон. Разница между мощностью 1 и 10 (линейной) после логарифмирования станет разницей между, условно, log(1)=0 и log(10)=1. Это позволяет на одной картинке одновременно увидеть и очень громкие, и очень тихие, но важные компоненты звука (шепот, слабые гармоники, шумы), которые в линейной шкале были бы просто не видны.


`n_mels`
n_mels - количество полос (фильтров) Мела
Что это: Количество фильтров в банке Mel-фильтров. Это определяет, на сколько частотных полос мы разбиваем наш звуковой диапазон.

Аналогия: Представьте, что вы делите пианино на группы клавиш:

n_mels=10 - вы делите всё пианино на 10 больших сегментов (очень грубо)

n_mels=128 - вы делите пианино на 128 маленьких сегментов (очень детально)

Как влияет на спектрограмму:
n_mels	Разрешение	Детализация	Размер данных	Использование
Малое (16-40)	Низкое	Грубая, "размытая" по частоте. Полосы широкие.	Маленький	Быстрые эксперименты, ритм-анализ, где точные частоты не важны.
Среднее (64-128)	Умеренное	Хороший баланс. Достаточно деталей для большинства задач.	Умеренный	Наиболее распространенный выбор. Распознавание речи, классификация звуков.
Большое (256+)	Высокое	Очень детальная. Можно видеть отдельные гармоники.	Большой	Сложные задачи: анализ музыки (тембр, инструменты), высотное детектирование.
Визуальный эффект:

Малое n_mels → спектрограмма будет "блочной", с вертикальными полосами

Большое n_mels → спектрограмма будет более гладкой и детализированной по частоте

`htk`
htk - способ расчета центров фильтров
Что это: Флаг, который определяет, по какой формуле рассчитываются центральные частоты Mel-фильтров.

htk=False (по умолчанию в librosa) - используется формула Slaney

htk=True - используется формула из инструментария HTK

Разница в формулах:
python
# HTK формула (htk=True)
mel_freq = 2595 * log10(1 + freq / 700)

# Slaney формула (htk=False)
mel_freq = 1127 * ln(1 + freq / 700)

При одинаковом n_mels=64:

htk=True - больше фильтров сконцентрировано в области 0-2 кГц
htk=False - более равномерное распределение фильтров по всему диапазону

Если важны низкие частоты (мужская речь, басовые инструменты) - попробуйте htk=True
Для экономии памяти/вычислений - уменьшайте n_mels до 64 или даже 32
Для музыки - часто лучше n_mels=256 чтобы захватить больше гармоник



hop_length	Временное разрешение	Временных кадров	Обнаружение быстрых событий	Эффективность
64	4.0 мс	~313 кадров	✅✅✅ Отлично	Высокая точность времени
256	16.0 мс	~78 кадров	✅✅ Хорошо	Баланс
512	32.0 мс	~39 кадров	✅ Удовлетворительно	Стандарт
1024	64.0 мс	~19 кадров	❌ Плохо	Пропускает короткие события
2048	128.0 мс	~10 кадров

Формула: частотное_разрешение = sampling_rate / n_fft

Пример для SR=16000 Гц:

python
n_fft = 512   → 16000/512  = 31.25 Гц/бин  # Низкое разрешение
n_fft = 2048  → 16000/2048 = 7.81 Гц/бин   # Среднее разрешение
n_fft = 4096  → 16000/4096 = 3.91 Гц/бин   # Высокое разрешение
Что это значит:

Большой n_fft → можно различать близкие частоты

Маленький n_fft → близкие частоты сливаются в одну

2. Временное разрешение - ОБРАТНАЯ ЗАВИСИМОСТЬ!
Принцип неопределенности Гейзенберга: нельзя одновременно иметь хорошее частотное и временное разрешение.

python
# Большое окно анализа = больше времени на анализ частот
n_fft = 4096 → окно = 4096/16000 = 0.256 секунды  # Хорошая частота, плохое время
n_fft = 512  → окно = 512/16000 = 0.032 секунды   # Хорошее время, плохая частота